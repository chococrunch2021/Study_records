### 멀티 쓰레드 모델 (1:N, 1:1, N:M 모델)

- 메모리 영역= 사용자에 의해 할당되는 공간인 `유저 영역` + 운영체제 소프트웨어 실행시키기 위한 공간인 `커널 영역`

- 사용자 수준 스레드와 커널 수준 스레드는 `생성 주체`가 누군지에 따라 구분된다

### 사용자 수준 스레드

- `라이브러리`에 의해 구현된 일반적인 스레드
- 운영체제가 멀티스레드를 지원하지 않을 때 사용하는 방법
  (라이브러리가 커널이 제공하는 `스케줄링, 동기화 기능을 대신 구현`해준다)
- 스레드와 관련된 모든 행위를 사용자 영역에서 한다

- 단일 프로세서에서 작동 (여러 개의 CPU를 사용할 수 없다)
- 커널이 스레드 존재 모른다 (프로세스로 인식한다)
- `다수의 사용자 수준 스레드`가 `커널 레벨 스레드 한 개에 매핑`된다 => N:1 매핑

- 장점
  - 라이브러리가 직접 스케줄링하고 필요한 정보를 처리하므로 `문맥 교환이 필요없다`
  - 운영체제에서 스레드 지원할 필요없음
  - 커널 모드/유저 모드 간 전환이 없어 오버헤드 적다
- 단점
  - 커널스레드가 입출력 작업 등으로 대기 상태에 들어가면 연결된 `모든 사용자 스레드가 같이 대기`하게 된다
  - 여러 개의 CPU를 사용할 수 없다. 커널은 사용자 스레드를 하나의 프로세스로 인식하므로 작업을 나눌 수 없다.
  - 커널처럼 공유 변수를 보호하는 장치가 없어 `보안에 취약`하다

### 커널 수준 스레드

- 커널이 스레드와 관련된 모든 작업 관리(커널에 종속적)
- 커널이 `멀티 스레드`를 지원하는 방식.
  (특정 스레드가 대기 하고 있어도 다른 스레드로 다른 작업 가능)
- 사용자스레드 1개가 커널 스레드 1개에 매핑된다 => 1:1 매핑
- 사용자 수준 스레드 한계 극복
- 장점
  - 각 커널이 스레드를 독립적으로 관리하여 병행 처리 가능
  - 멀티 CPU사용 가능하다
  - 커널이 직접 제공해주므로 안정성(보안이 좋다)과 다양한 기능이 제공
- 단점
  - 커널과 유저모드 간 전환이 빈번하게 이루어져 오버헤드가 커진다

### 혼합 스레드 (Multiplexed Thread), 멀티레벨 스레드, 하이브리드 스레드

- 사용자 수준 스레드 + 커널 수준 스레드 => N:M 매핑
- 사용자 수준 스레드 개수 >= 커널 수준 스레드

- 하나의 커널 스레드가 대기 상태 들어가면 다른 커널 스레드가 대신 작업한다
- 문맥 교환 시 오버헤드가 있어 사용자 스레드만큼 빠르지 않다
- 빠르게 움직여야하는 스레드는 사용자스레드로, 안정적이여야 하는 스레드는 커널 스레드로 작동한다

---

- 출처
  - [사용자수준스레드, 커널 수준 스레드](<https://sujinhope.github.io/2019/12/19/CS-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C(OS)-%EB%A9%B4%EC%A0%91-%EC%A7%88%EB%AC%B8(%EA%B8%B0%EC%88%A0%EB%A9%B4%EC%A0%91-%EB%8C%80%EB%B9%84).html#title2>)
  - 도서: 쉽게 배우는 운영체제
